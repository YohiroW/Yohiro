---
title: Lumen
author: Yohiro
date: 2022-05-04
categories: []
tags: []
render_with_liquid: false
img_path: /assets/images/Lumen/
---

## Overview

UE 各个模块的设计中，有一个显而易见的思路，那就是将模块抽象为一个场景，将各模块所需要的数据与原数据解耦从而独立处理。比如在我们通常看到的关卡场景中，关卡中的内容是各种 Actor 以及 Component；在物理场景中，物理场景看到的是各种碰撞体；在渲染场景中，渲染场景看到的是各种 PrimitiveSceneProxy。Lumen 的设计也大致如此，通过 SDF 获得简化的场景以及场景的材质信息(Surface Cache)，然后再通过分帧计算，最终达到近乎实时的 GI 效果。

## Lumen Scene

要解决间接光的反弹问题，需要考虑如何追踪光线。部分显卡有光追单元进行加速，但相当一部分显卡还是缺少硬件支持。此外，硬件光追的二级加速架构在处理大量重叠网格时效率也并不是很好，因此需要额外的软光追来解决这些问题。

### MeshCard

Epic 先是引入了 MeshCard 这一概念，即使用 2D 正交的相机对 Mesh 的 N 个面进行拍摄，在渲染时通过 MeshCard 的高度场信息来做光追。在引擎中的 StaticMesh 的 BuildSetting 中有针对 Mesh 的最大 Card 数量的限制：
![MaxMeshCard](MeshCardConfig.png)

但 Card 的表示在场景比较复杂（遮挡，动态）时，光追的结果很可能时错误的，这种情况下会造成漏光的问题。

### SDF

为解决仅使用 Card 的场景中，错误的光追造成的问题，引入了 SDF。SDF 可以提供更为可信的遮挡信息，但是 SDF 的问题是，它只能提供光线碰到的点和该点的法向量，无法更进一步的获取到该点的光照和材质信息。

### Surface Cache

综合以上二者的优劣，Lumen 最终使用 SDF 用于光追，再通过 SDF 获得 Card 中的材质光照信息。这样一来可能会因为 Card 的几何特性导致光照能量损失，但不会漏光。这个方案就是 Surface Cache。通过 Surface Cache 完成材质共享以及跨帧缓存，在使用硬件光追的情况下，也可以通过追踪 Surface Cache 的几何信息来简化计算。

### 场景更新

在整个关于 Lumen 的渲染 Pipeline 中，最先执行的是 LumenSceneUpdate。更新时会重新捕获 MeshCard 的信息，并在最后将他们拷贝到 SurfaceCache 之中。这个过程中，最终的 Mesh 数据会被渲染四张 LumenRT 上：Lumen.SceneDirectLighting，Lumen.SceneFinalLighting，Lumen.SceneIndirectLighting 以及 Lumen.SceneNumFramesAccumulatedAtlas。

## Lumen Scene Lighting

确定了如何追踪光线，那么接下来的两个问题是如何处理间接光的反弹和如何处理光线传输过程中的噪点。

光线的第一次反弹对于最终的颜色有较大的影响，因此需要单独处理，对于 Diffuse，引擎中叫做 FinalGather，对于反射，引擎中要做的是反射降噪。在产生第一次反弹后的光线会通过 Surface Cache 读取。

### Final Gather

Final Gather 会使用自适应的降采样方法去追踪尽可能少的光线，并在时域和空域内充分利用采样信息

### 更新上下文

### 直接光照

### Radiosity

## Screen Probe Gather

## 参考

- [SIGGRAPH2022-Advances-Lumen-Wright et al](https://advances.realtimerendering.com/s2022/SIGGRAPH2022-Advances-Lumen-Wright%20et%20al.pdf)

